/**
 * Sequential Workflow Engine
 *
 * Executes workflow steps in topological order with worktree reuse.
 * Supports both sequential and parallel execution modes.
 */

import type Database from "better-sqlite3";
import { exec } from "child_process";
import { promisify } from "util";
import type {
  Workflow,
  WorkflowSource,
  WorkflowConfig,
  WorkflowStep,
  Issue,
  Execution,
} from "@sudocode-ai/types";
import {
  getIssue,
  updateIssue,
} from "@sudocode-ai/cli/dist/operations/issues.js";

const execAsync = promisify(exec);

import { BaseWorkflowEngine } from "../base-workflow-engine.js";
import {
  WorkflowCycleError,
  WorkflowStateError,
  WorkflowStepNotFoundError,
} from "../workflow-engine.js";
import type { WorkflowEventEmitter } from "../workflow-event-emitter.js";
import type { ExecutionService } from "../../services/execution-service.js";
import type { ExecutionConfig } from "../../services/execution-service.js";
import { getExecution } from "../../services/executions.js";

// =============================================================================
// Types
// =============================================================================

/**
 * Internal state for tracking active workflows.
 * Used for pause/resume/cancel coordination.
 */
interface WorkflowState {
  workflowId: string;
  isPaused: boolean;
  isCancelled: boolean;
  currentExecutionId?: string;
}

// =============================================================================
// Sequential Workflow Engine
// =============================================================================

/**
 * Sequential Workflow Engine implementation.
 *
 * Executes workflow steps in topological order (respecting dependencies).
 * Features:
 * - Single shared worktree for all steps
 * - Auto-commit after each step (configurable)
 * - Configurable failure handling (stop, pause, skip_dependents, continue)
 * - Support for parallel execution of independent steps
 *
 * @example
 * ```typescript
 * const engine = new SequentialWorkflowEngine(db, executionService, repoPath);
 *
 * // Create workflow from a spec
 * const workflow = await engine.createWorkflow({
 *   type: "spec",
 *   specId: "s-auth"
 * });
 *
 * // Start execution
 * await engine.startWorkflow(workflow.id);
 *
 * // Subscribe to events
 * engine.onWorkflowEvent((event) => {
 *   console.log(event.type, event);
 * });
 * ```
 */
export class SequentialWorkflowEngine extends BaseWorkflowEngine {
  private executionService: ExecutionService;
  private repoPath: string;
  private activeWorkflows = new Map<string, WorkflowState>();

  constructor(
    db: Database.Database,
    executionService: ExecutionService,
    repoPath: string,
    eventEmitter?: WorkflowEventEmitter
  ) {
    super(db, eventEmitter);
    this.executionService = executionService;
    this.repoPath = repoPath;
  }

  // ===========================================================================
  // Workflow Creation
  // ===========================================================================

  /**
   * Create a new workflow from a source definition.
   *
   * @param source - How to determine workflow scope (spec, issues, root_issue, or goal)
   * @param config - Optional configuration overrides (includes baseBranch, title)
   * @returns The created workflow
   * @throws WorkflowCycleError if dependency cycles are detected
   */
  async createWorkflow(
    source: WorkflowSource,
    config?: Partial<WorkflowConfig>
  ): Promise<Workflow> {
    // 1. Resolve source to issue IDs
    const issueIds = await this.resolveSource(source);

    // 2. Handle goal-based workflows (no initial issues)
    if (source.type === "goal" && issueIds.length === 0) {
      // Goal workflows start with no steps - orchestrator creates them
      const workflow = this.buildWorkflow({
        source,
        steps: [],
        config: config || {},
        repoPath: this.repoPath,
      });
      this.saveWorkflow(workflow);
      return workflow;
    }

    // 3. Build dependency graph
    const graph = this.analyzeDependencies(issueIds);

    // 4. Check for cycles
    if (graph.cycles && graph.cycles.length > 0) {
      throw new WorkflowCycleError(graph.cycles);
    }

    // 5. Create steps from graph
    const steps = this.createStepsFromGraph(graph);

    // 6. Build workflow object
    const workflow = this.buildWorkflow({
      source,
      steps,
      config: config || {},
      repoPath: this.repoPath,
    });

    // 7. Save to database
    this.saveWorkflow(workflow);

    return workflow;
  }

  // ===========================================================================
  // Workflow Lifecycle
  // ===========================================================================

  /**
   * Start executing a pending workflow.
   *
   * Creates a worktree and begins the execution loop.
   *
   * @param workflowId - The workflow to start
   * @throws WorkflowNotFoundError if workflow doesn't exist
   * @throws WorkflowStateError if workflow is not in pending state
   */
  async startWorkflow(workflowId: string): Promise<void> {
    const workflow = await this.getWorkflowOrThrow(workflowId);

    // Validate state
    if (workflow.status !== "pending") {
      throw new WorkflowStateError(workflowId, workflow.status, "start");
    }

    // Initialize workflow state
    this.activeWorkflows.set(workflowId, {
      workflowId,
      isPaused: false,
      isCancelled: false,
    });

    // Update status to running
    const updated = this.updateWorkflow(workflowId, {
      status: "running",
      startedAt: new Date().toISOString(),
    });

    // Emit workflow started event
    this.eventEmitter.emit({
      type: "workflow_started",
      workflowId,
      workflow: updated,
      timestamp: Date.now(),
    });

    // Start execution loop (non-blocking)
    this.runExecutionLoop(workflowId).catch((error) => {
      console.error(`Workflow ${workflowId} execution loop failed:`, error);
      this.failWorkflow(workflowId, error.message).catch(console.error);
    });
  }

  /**
   * Pause a running workflow after the current step completes.
   *
   * @param workflowId - The workflow to pause
   * @throws WorkflowNotFoundError if workflow doesn't exist
   * @throws WorkflowStateError if workflow is not running
   */
  async pauseWorkflow(workflowId: string): Promise<void> {
    const workflow = await this.getWorkflowOrThrow(workflowId);

    if (workflow.status !== "running") {
      throw new WorkflowStateError(workflowId, workflow.status, "pause");
    }

    // Set pause flag for execution loop
    const state = this.activeWorkflows.get(workflowId);
    if (state) {
      state.isPaused = true;
    }

    // Update status
    this.updateWorkflow(workflowId, { status: "paused" });

    // Emit event
    this.eventEmitter.emit({
      type: "workflow_paused",
      workflowId,
      timestamp: Date.now(),
    });
  }

  /**
   * Resume a paused workflow.
   *
   * @param workflowId - The workflow to resume
   * @throws WorkflowNotFoundError if workflow doesn't exist
   * @throws WorkflowStateError if workflow is not paused
   */
  async resumeWorkflow(workflowId: string): Promise<void> {
    const workflow = await this.getWorkflowOrThrow(workflowId);

    if (workflow.status !== "paused") {
      throw new WorkflowStateError(workflowId, workflow.status, "resume");
    }

    // Clear pause flag
    let state = this.activeWorkflows.get(workflowId);
    if (!state) {
      state = {
        workflowId,
        isPaused: false,
        isCancelled: false,
      };
      this.activeWorkflows.set(workflowId, state);
    }
    state.isPaused = false;

    // Update status
    this.updateWorkflow(workflowId, { status: "running" });

    // Emit event
    this.eventEmitter.emit({
      type: "workflow_resumed",
      workflowId,
      timestamp: Date.now(),
    });

    // Restart execution loop
    this.runExecutionLoop(workflowId).catch((error) => {
      console.error(`Workflow ${workflowId} execution loop failed:`, error);
      this.failWorkflow(workflowId, error.message).catch(console.error);
    });
  }

  /**
   * Cancel a workflow, stopping any running executions.
   *
   * @param workflowId - The workflow to cancel
   * @throws WorkflowNotFoundError if workflow doesn't exist
   * @throws WorkflowStateError if workflow is already completed/failed/cancelled
   */
  async cancelWorkflow(workflowId: string): Promise<void> {
    const workflow = await this.getWorkflowOrThrow(workflowId);

    // Check if already in terminal state
    if (["completed", "failed", "cancelled"].includes(workflow.status)) {
      throw new WorkflowStateError(workflowId, workflow.status, "cancel");
    }

    // Set cancel flag
    const state = this.activeWorkflows.get(workflowId);
    if (state) {
      state.isCancelled = true;

      // Cancel current execution if running
      if (state.currentExecutionId) {
        try {
          await this.executionService.cancelExecution(state.currentExecutionId);
        } catch (error) {
          console.warn(
            `Failed to cancel execution ${state.currentExecutionId}:`,
            error
          );
        }
      }
    }

    // Update status
    this.updateWorkflow(workflowId, {
      status: "cancelled",
      completedAt: new Date().toISOString(),
    });

    // Emit event
    this.eventEmitter.emit({
      type: "workflow_cancelled",
      workflowId,
      timestamp: Date.now(),
    });

    // Cleanup
    this.activeWorkflows.delete(workflowId);
  }

  // ===========================================================================
  // Step Control
  // ===========================================================================

  /**
   * Retry a failed step.
   *
   * Resets the step status to pending and unblocks dependent steps.
   * If the workflow was paused due to the failure, it will be resumed.
   *
   * @param workflowId - The workflow containing the step
   * @param stepId - The step to retry
   * @throws WorkflowNotFoundError if workflow doesn't exist
   * @throws WorkflowStepNotFoundError if step doesn't exist
   * @throws WorkflowStateError if step is not in failed state
   */
  async retryStep(workflowId: string, stepId: string): Promise<void> {
    const workflow = await this.getWorkflowOrThrow(workflowId);
    const step = workflow.steps.find((s) => s.id === stepId);

    if (!step) {
      throw new WorkflowStepNotFoundError(workflowId, stepId);
    }

    if (step.status !== "failed") {
      throw new WorkflowStateError(
        workflowId,
        `step ${stepId} is ${step.status}`,
        "retry"
      );
    }

    // Reset step status
    this.updateStep(workflowId, stepId, {
      status: "pending",
      error: undefined,
      executionId: undefined,
    });

    // Unblock dependent steps
    await this.unblockDependentSteps(workflow, step);

    // Resume workflow if paused
    if (workflow.status === "paused") {
      await this.resumeWorkflow(workflowId);
    }
  }

  /**
   * Skip a step and handle its dependents.
   *
   * @param workflowId - The workflow containing the step
   * @param stepId - The step to skip
   * @param reason - Optional reason for skipping
   * @throws WorkflowNotFoundError if workflow doesn't exist
   * @throws WorkflowStepNotFoundError if step doesn't exist
   */
  async skipStep(
    workflowId: string,
    stepId: string,
    reason?: string
  ): Promise<void> {
    const workflow = await this.getWorkflowOrThrow(workflowId);
    const step = workflow.steps.find((s) => s.id === stepId);

    if (!step) {
      throw new WorkflowStepNotFoundError(workflowId, stepId);
    }

    const skipReason = reason || "Manually skipped";

    // Mark as skipped
    this.updateStep(workflowId, stepId, {
      status: "skipped",
      error: skipReason,
    });

    // Emit event
    this.eventEmitter.emit({
      type: "step_skipped",
      workflowId,
      step: { ...step, status: "skipped", error: skipReason },
      reason: skipReason,
      timestamp: Date.now(),
    });

    // Handle dependents based on config
    if (workflow.config.onFailure === "skip_dependents") {
      await this.skipDependentSteps(workflow, step, "Dependency skipped");
    } else {
      await this.blockDependentSteps(workflow, step);
    }

    // Resume workflow if paused
    if (workflow.status === "paused") {
      await this.resumeWorkflow(workflowId);
    }
  }

  // ===========================================================================
  // Execution Loop
  // ===========================================================================

  /**
   * Main execution loop for the workflow.
   * Runs steps in topological order, respecting dependencies.
   *
   * @param workflowId - The workflow to execute
   */
  private async runExecutionLoop(workflowId: string): Promise<void> {
    while (true) {
      // Check workflow state
      const state = this.activeWorkflows.get(workflowId);
      if (!state || state.isPaused || state.isCancelled) {
        break;
      }

      // Get current workflow state
      const workflow = await this.getWorkflowOrThrow(workflowId);

      // Check if workflow is complete
      if (this.isWorkflowComplete(workflow)) {
        await this.completeWorkflow(workflowId);
        break;
      }

      // Get ready steps (dependencies satisfied)
      const readySteps = await this.getReadySteps(workflowId);

      if (readySteps.length === 0) {
        // No ready steps but workflow not complete - likely all remaining steps are blocked
        // This can happen if a step fails and dependents are blocked
        const hasBlockedOrFailed = workflow.steps.some(
          (s) => s.status === "blocked" || s.status === "failed"
        );
        if (hasBlockedOrFailed) {
          // Workflow is stuck, wait for user intervention (retry/skip)
          break;
        }
        // Should not happen - safeguard against infinite loop
        console.warn(
          `Workflow ${workflowId}: No ready steps but workflow not complete`
        );
        break;
      }

      // Execute steps based on parallelism config
      if (workflow.config.parallelism === "sequential") {
        // Execute one step at a time
        await this.executeStep(workflow, readySteps[0]);
      } else {
        // Execute multiple ready steps in parallel mode
        // Note: For Phase 4, this uses shared worktree with sequential commits
        // True parallel execution with separate branches is a future enhancement
        await this.executeParallel(workflow, readySteps);
      }
    }
  }

  /**
   * Execute multiple steps in parallel mode.
   *
   * For Phase 4, this uses a shared worktree with sequential commits.
   * Steps are executed one after another but all ready steps in the batch
   * are processed before re-checking dependencies.
   *
   * Future enhancement: True parallel execution with separate branches
   * and merge handling.
   *
   * @param workflow - The workflow containing the steps
   * @param steps - The ready steps to execute
   */
  private async executeParallel(
    workflow: Workflow,
    steps: WorkflowStep[]
  ): Promise<void> {
    // Respect maxConcurrency limit
    const maxConcurrency = workflow.config.maxConcurrency ?? steps.length;
    const toExecute = steps.slice(0, maxConcurrency);

    // Track failed steps for batch failure handling
    const failedSteps: WorkflowStep[] = [];

    // Execute steps sequentially within the batch
    // (shared worktree requires sequential commits)
    for (const step of toExecute) {
      // Check for pause/cancel between steps
      const state = this.activeWorkflows.get(workflow.id);
      if (!state || state.isPaused || state.isCancelled) {
        break;
      }

      try {
        await this.executeStep(workflow, step);

        // Refresh workflow state to check if step succeeded
        const updatedWorkflow = await this.getWorkflowOrThrow(workflow.id);
        const updatedStep = updatedWorkflow.steps.find((s) => s.id === step.id);

        if (updatedStep?.status === "failed") {
          failedSteps.push(updatedStep);

          // For "stop" strategy, break immediately
          if (workflow.config.onFailure === "stop") {
            break;
          }
          // For "pause" strategy, the workflow is already paused by handleStepFailure
          if (updatedWorkflow.status === "paused") {
            break;
          }
        }
      } catch (error) {
        // Unexpected error during step execution
        console.error(`Error executing step ${step.id}:`, error);
        failedSteps.push(step);

        if (workflow.config.onFailure === "stop") {
          throw error;
        }
      }
    }
  }

  /**
   * Execute a single workflow step.
   *
   * @param workflow - The workflow containing the step
   * @param step - The step to execute
   */
  private async executeStep(
    workflow: Workflow,
    step: WorkflowStep
  ): Promise<void> {
    const state = this.activeWorkflows.get(workflow.id);

    // 1. Get issue details for prompt
    const issue = getIssue(this.db, step.issueId);
    if (!issue) {
      throw new Error(`Issue ${step.issueId} not found`);
    }

    // 2. Build execution config
    const config: ExecutionConfig = {
      mode: "worktree",
      baseBranch: workflow.baseBranch,
      createBaseBranch: workflow.config.createBaseBranch,
    };

    // Reuse worktree if we have a previous execution in this workflow
    const previousWorktreePath = this.getFirstWorktreePath(workflow);
    if (previousWorktreePath) {
      config.reuseWorktreePath = previousWorktreePath;
    } else if (workflow.config.reuseWorktreePath) {
      // For the first step, use user-specified worktree from config
      config.reuseWorktreePath = workflow.config.reuseWorktreePath;
    }

    // 3. Build prompt
    const prompt = this.buildPrompt(issue, workflow);

    // 4. Update step status to running
    this.updateStep(workflow.id, step.id, {
      status: "running",
    });

    // 5. Emit step started event
    this.eventEmitter.emit({
      type: "step_started",
      workflowId: workflow.id,
      step: { ...step, status: "running" },
      timestamp: Date.now(),
    });

    // 6. Create execution
    const execution = await this.executionService.createExecution(
      step.issueId,
      config,
      prompt,
      workflow.config.defaultAgentType
    );

    // Track current execution
    if (state) {
      state.currentExecutionId = execution.id;
    }

    // Update step with execution ID
    this.updateStep(workflow.id, step.id, {
      executionId: execution.id,
    });

    // 7. Wait for execution to complete
    const completedExecution = await this.waitForExecution(execution.id);

    // Clear current execution tracking
    if (state) {
      state.currentExecutionId = undefined;
    }

    // 8. Handle result
    if (completedExecution.status === "completed") {
      await this.handleStepSuccess(workflow, step, completedExecution);
    } else {
      await this.handleStepFailure(workflow, step, completedExecution);
    }
  }

  /**
   * Wait for an execution to complete by polling.
   *
   * @param executionId - The execution to wait for
   * @returns The completed execution
   */
  private async waitForExecution(executionId: string): Promise<Execution> {
    const pollIntervalMs = 1000; // 1 second
    const maxWaitMs = 60 * 60 * 1000; // 1 hour max
    const startTime = Date.now();

    while (true) {
      const execution = getExecution(this.db, executionId);
      if (!execution) {
        throw new Error(`Execution ${executionId} not found`);
      }

      // Check if execution is in a terminal state
      if (
        execution.status === "completed" ||
        execution.status === "failed" ||
        execution.status === "stopped" ||
        execution.status === "cancelled"
      ) {
        return execution;
      }

      // Check timeout
      if (Date.now() - startTime > maxWaitMs) {
        throw new Error(
          `Execution ${executionId} timed out after ${maxWaitMs}ms`
        );
      }

      // Wait before next poll
      await this.sleep(pollIntervalMs);
    }
  }

  /**
   * Sleep for a specified duration.
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Build the prompt for executing an issue.
   *
   * @param issue - The issue to execute
   * @param workflow - The workflow context
   * @returns The prompt string
   */
  private buildPrompt(issue: Issue, workflow: Workflow): string {
    // Build a basic prompt from issue details
    const parts: string[] = [];

    parts.push(`# Task: ${issue.title}`);
    parts.push("");

    if (issue.content) {
      parts.push("## Description");
      parts.push(issue.content);
      parts.push("");
    }

    // Add workflow context
    parts.push("## Workflow Context");
    parts.push(
      `This is step ${workflow.currentStepIndex + 1} of ${workflow.steps.length} in workflow "${workflow.title}".`
    );

    return parts.join("\n");
  }

  /**
   * Get the worktree path from the first completed step's execution.
   * Used for reusing the same worktree across workflow steps.
   *
   * @param workflow - The workflow to search
   * @returns The worktree path or undefined
   */
  private getFirstWorktreePath(workflow: Workflow): string | undefined {
    for (const step of workflow.steps) {
      if (step.status === "completed" && step.executionId) {
        const execution = this.db
          .prepare("SELECT worktree_path FROM executions WHERE id = ?")
          .get(step.executionId) as { worktree_path: string | null } | undefined;
        if (execution?.worktree_path) {
          return execution.worktree_path;
        }
      }
    }
    return undefined;
  }

  /**
   * Handle successful step completion.
   *
   * @param workflow - The workflow containing the step
   * @param step - The completed step
   * @param execution - The execution result
   */
  private async handleStepSuccess(
    workflow: Workflow,
    step: WorkflowStep,
    execution: Execution
  ): Promise<void> {
    // Convert null to undefined for type compatibility
    let commitSha = execution.after_commit ?? undefined;

    // Auto-commit if configured and we have a worktree
    if (workflow.config.autoCommitAfterStep && workflow.worktreePath) {
      const newCommitSha = await this.commitStepChanges(workflow, step);
      if (newCommitSha) {
        commitSha = newCommitSha;
      }
    }

    // Update step status
    this.updateStep(workflow.id, step.id, {
      status: "completed",
      commitSha,
    });

    // Emit event
    this.eventEmitter.emit({
      type: "step_completed",
      workflowId: workflow.id,
      step: { ...step, status: "completed", commitSha },
      executionId: execution.id,
      timestamp: Date.now(),
    });

    // Update workflow progress
    this.updateWorkflow(workflow.id, {
      currentStepIndex: workflow.currentStepIndex + 1,
    });

    // Close the issue after successful step completion
    await this.closeIssue(step.issueId);
  }

  /**
   * Commit step changes to git.
   *
   * @param workflow - The workflow containing the step
   * @param step - The completed step
   * @returns The commit SHA if successful, null otherwise
   */
  private async commitStepChanges(
    workflow: Workflow,
    step: WorkflowStep
  ): Promise<string | null> {
    if (!workflow.worktreePath) {
      return null;
    }

    const issue = getIssue(this.db, step.issueId);
    const message = this.buildCommitMessage(workflow, step, issue);

    try {
      // Check if there are changes to commit
      const { stdout: status } = await execAsync("git status --porcelain", {
        cwd: workflow.worktreePath,
        maxBuffer: 10 * 1024 * 1024,
      });

      if (!status.trim()) {
        // No changes to commit
        return null;
      }

      // Stage all changes and commit
      // Escape double quotes in message for shell safety
      const escapedMessage = message.replace(/"/g, '\\"');
      await execAsync(`git add -A && git commit -m "${escapedMessage}"`, {
        cwd: workflow.worktreePath,
        maxBuffer: 10 * 1024 * 1024,
      });

      // Get new commit SHA
      const { stdout: sha } = await execAsync("git rev-parse HEAD", {
        cwd: workflow.worktreePath,
      });

      return sha.trim();
    } catch (error) {
      console.error("Failed to commit step changes:", error);
      return null;
    }
  }

  /**
   * Build commit message for a step.
   *
   * @param workflow - The workflow
   * @param step - The completed step
   * @param issue - The issue (may be null)
   * @returns The commit message
   */
  private buildCommitMessage(
    workflow: Workflow,
    step: WorkflowStep,
    issue: Issue | null
  ): string {
    const issueTitle = issue?.title || "Unknown issue";
    const stepNum = step.index + 1;
    const totalSteps = workflow.steps.length;

    return `[Workflow ${stepNum}/${totalSteps}] ${step.issueId}: ${issueTitle}

Workflow: ${workflow.title}
Step: ${stepNum} of ${totalSteps}`;
  }

  /**
   * Close an issue after successful step completion.
   *
   * @param issueId - The issue ID to close
   */
  private async closeIssue(issueId: string): Promise<void> {
    try {
      updateIssue(this.db, issueId, { status: "closed" });
    } catch (error) {
      // Non-fatal - log but don't fail
      console.warn(`Failed to close issue ${issueId}:`, error);
    }
  }

  /**
   * Handle step failure.
   *
   * @param workflow - The workflow containing the step
   * @param step - The failed step
   * @param execution - The execution result
   */
  private async handleStepFailure(
    workflow: Workflow,
    step: WorkflowStep,
    execution: Execution
  ): Promise<void> {
    const errorMessage = execution.error_message || "Unknown error";

    // Update step status
    this.updateStep(workflow.id, step.id, {
      status: "failed",
      error: errorMessage,
    });

    // Emit event
    this.eventEmitter.emit({
      type: "step_failed",
      workflowId: workflow.id,
      step: { ...step, status: "failed", error: errorMessage },
      error: errorMessage,
      timestamp: Date.now(),
    });

    // Handle based on failure strategy
    switch (workflow.config.onFailure) {
      case "stop":
        await this.failWorkflow(
          workflow.id,
          `Step ${step.id} failed: ${errorMessage}`
        );
        break;

      case "pause":
        await this.pauseWorkflow(workflow.id);
        break;

      case "skip_dependents":
        await this.skipDependentSteps(
          workflow,
          step,
          `Dependency ${step.issueId} failed`
        );
        break;

      case "continue":
        // Mark dependents as blocked, continue with other steps
        await this.blockDependentSteps(workflow, step);
        break;
    }
  }

  // ===========================================================================
  // Helper Methods
  // ===========================================================================

  /**
   * Mark workflow as failed.
   */
  private async failWorkflow(workflowId: string, error: string): Promise<void> {
    this.updateWorkflow(workflowId, {
      status: "failed",
      completedAt: new Date().toISOString(),
    });

    this.eventEmitter.emit({
      type: "workflow_failed",
      workflowId,
      error,
      timestamp: Date.now(),
    });

    this.activeWorkflows.delete(workflowId);
  }

  /**
   * Mark workflow as completed.
   */
  protected async completeWorkflow(workflowId: string): Promise<void> {
    const workflow = await this.getWorkflowOrThrow(workflowId);

    this.updateWorkflow(workflowId, {
      status: "completed",
      completedAt: new Date().toISOString(),
    });

    this.eventEmitter.emit({
      type: "workflow_completed",
      workflowId,
      workflow: { ...workflow, status: "completed" },
      timestamp: Date.now(),
    });

    this.activeWorkflows.delete(workflowId);
  }

  /**
   * Check if workflow is complete (all steps done or skipped).
   */
  protected isWorkflowComplete(workflow: Workflow): boolean {
    return workflow.steps.every(
      (step) =>
        step.status === "completed" ||
        step.status === "skipped" ||
        step.status === "blocked"
    );
  }

  /**
   * Find all steps that transitively depend on a given step.
   */
  protected findDependentSteps(
    workflow: Workflow,
    stepId: string
  ): WorkflowStep[] {
    const dependents: WorkflowStep[] = [];
    const visited = new Set<string>();
    const queue = [stepId];

    while (queue.length > 0) {
      const current = queue.shift()!;

      for (const step of workflow.steps) {
        if (step.dependencies.includes(current) && !visited.has(step.id)) {
          visited.add(step.id);
          dependents.push(step);
          queue.push(step.id);
        }
      }
    }

    return dependents;
  }

  /**
   * Skip all steps that depend on a failed/skipped step.
   */
  protected async skipDependentSteps(
    workflow: Workflow,
    failedStep: WorkflowStep,
    reason: string
  ): Promise<void> {
    const dependents = this.findDependentSteps(workflow, failedStep.id);

    for (const step of dependents) {
      if (step.status === "pending" || step.status === "ready") {
        this.updateStep(workflow.id, step.id, {
          status: "skipped",
          error: reason,
        });

        this.eventEmitter.emit({
          type: "step_skipped",
          workflowId: workflow.id,
          step: { ...step, status: "skipped", error: reason },
          reason,
          timestamp: Date.now(),
        });
      }
    }
  }

  /**
   * Block all steps that depend on a failed step.
   */
  protected async blockDependentSteps(
    workflow: Workflow,
    failedStep: WorkflowStep
  ): Promise<void> {
    const dependents = this.findDependentSteps(workflow, failedStep.id);

    for (const step of dependents) {
      if (step.status === "pending" || step.status === "ready") {
        this.updateStep(workflow.id, step.id, {
          status: "blocked",
        });
      }
    }
  }

  /**
   * Unblock steps that were blocked due to a failed dependency.
   */
  protected async unblockDependentSteps(
    workflow: Workflow,
    retriedStep: WorkflowStep
  ): Promise<void> {
    const dependents = this.findDependentSteps(workflow, retriedStep.id);

    for (const step of dependents) {
      if (step.status === "blocked") {
        this.updateStep(workflow.id, step.id, {
          status: "pending",
        });
      }
    }
  }
}
