/**
 * Unit tests for OrchestratorWorkflowEngine
 *
 * Tests:
 * - Workflow creation with different sources
 * - Orchestrator spawning on start
 * - Pause/resume state transitions
 * - Cancel workflow with execution cleanup
 * - Step control (retry/skip) events
 */

import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import Database from "better-sqlite3";
import type { Workflow, Issue } from "@sudocode-ai/types";
import {
  WORKFLOWS_TABLE,
  WORKFLOW_EVENTS_TABLE,
  EXECUTIONS_TABLE,
} from "@sudocode-ai/types/schema";

import { OrchestratorWorkflowEngine } from "../../../../src/workflow/engines/orchestrator-engine.js";
import { WorkflowEventEmitter } from "../../../../src/workflow/workflow-event-emitter.js";
import { WorkflowWakeupService } from "../../../../src/workflow/services/wakeup-service.js";
import { WorkflowPromptBuilder } from "../../../../src/workflow/services/prompt-builder.js";
import type { ExecutionService } from "../../../../src/services/execution-service.js";

// =============================================================================
// Test Setup
// =============================================================================

function createTestDb(): Database.Database {
  const db = new Database(":memory:");

  // Disable foreign key enforcement for tests
  db.exec("PRAGMA foreign_keys = OFF");

  // Create tables
  db.exec(WORKFLOWS_TABLE);
  db.exec(EXECUTIONS_TABLE);
  db.exec(WORKFLOW_EVENTS_TABLE);

  // Create minimal issues table for resolveSource
  db.exec(`
    CREATE TABLE IF NOT EXISTS issues (
      id TEXT PRIMARY KEY,
      uuid TEXT NOT NULL,
      title TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'open',
      content TEXT,
      priority INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Create relationships table for dependency resolution
  db.exec(`
    CREATE TABLE IF NOT EXISTS relationships (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      from_id TEXT NOT NULL,
      from_uuid TEXT,
      from_type TEXT NOT NULL,
      to_id TEXT NOT NULL,
      to_uuid TEXT,
      to_type TEXT NOT NULL,
      relationship_type TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      metadata TEXT
    )
  `);

  return db;
}

function createMockExecutionService(): ExecutionService {
  return {
    createExecution: vi.fn().mockResolvedValue({
      id: "exec-orch",
      session_id: "session-orch",
      status: "running",
    }),
    cancelExecution: vi.fn().mockResolvedValue(undefined),
    createFollowUp: vi.fn().mockResolvedValue({
      id: "exec-followup",
      session_id: "session-orch",
      status: "running",
    }),
  } as unknown as ExecutionService;
}

function createTestIssue(
  db: Database.Database,
  id: string,
  title: string
): void {
  db.prepare(
    `INSERT INTO issues (id, uuid, title, status) VALUES (?, ?, ?, 'open')`
  ).run(id, `uuid-${id}`, title);
}

// =============================================================================
// Tests
// =============================================================================

describe("OrchestratorWorkflowEngine", () => {
  let db: Database.Database;
  let executionService: ExecutionService;
  let wakeupService: WorkflowWakeupService;
  let eventEmitter: WorkflowEventEmitter;
  let engine: OrchestratorWorkflowEngine;

  beforeEach(() => {
    db = createTestDb();
    executionService = createMockExecutionService();
    eventEmitter = new WorkflowEventEmitter();
    const promptBuilder = new WorkflowPromptBuilder();

    wakeupService = new WorkflowWakeupService({
      db,
      executionService,
      promptBuilder,
      eventEmitter,
      config: { batchWindowMs: 100 },
    });

    engine = new OrchestratorWorkflowEngine({
      db,
      executionService,
      wakeupService,
      eventEmitter,
      config: {
        repoPath: "/test/repo",
        dbPath: "/test/.sudocode/cache.db",
      },
    });
  });

  afterEach(() => {
    wakeupService.stop();
    db.close();
  });

  describe("createWorkflow", () => {
    it("should create workflow from goal source with no steps", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Implement user authentication",
      });

      expect(workflow.id).toMatch(/^wf-/);
      expect(workflow.title).toBe("Implement user authentication");
      expect(workflow.status).toBe("pending");
      expect(workflow.steps).toHaveLength(0);
      expect(workflow.source).toEqual({
        type: "goal",
        goal: "Implement user authentication",
      });
    });

    it("should create workflow from issues source with steps", async () => {
      // Create test issues
      createTestIssue(db, "i-1", "First issue");
      createTestIssue(db, "i-2", "Second issue");

      const workflow = await engine.createWorkflow({
        type: "issues",
        issueIds: ["i-1", "i-2"],
      });

      expect(workflow.steps).toHaveLength(2);
      expect(workflow.steps.map((s) => s.issueId)).toContain("i-1");
      expect(workflow.steps.map((s) => s.issueId)).toContain("i-2");
    });

    it("should save workflow to database", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test goal",
      });

      const saved = await engine.getWorkflow(workflow.id);
      expect(saved).not.toBeNull();
      expect(saved!.id).toBe(workflow.id);
    });

    it("should merge config with defaults", async () => {
      const workflow = await engine.createWorkflow(
        { type: "goal", goal: "Test" },
        {
          autonomyLevel: "full_auto",
          orchestratorModel: "claude-opus-4",
        }
      );

      expect(workflow.config.autonomyLevel).toBe("full_auto");
      expect(workflow.config.orchestratorModel).toBe("claude-opus-4");
      expect(workflow.config.defaultAgentType).toBe("claude-code"); // Default
    });
  });

  describe("startWorkflow", () => {
    it("should spawn orchestrator execution", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test workflow",
      });

      await engine.startWorkflow(workflow.id);

      expect(executionService.createExecution).toHaveBeenCalledTimes(1);
      expect(executionService.createExecution).toHaveBeenCalledWith(
        null, // No issue for orchestrator
        expect.objectContaining({
          mode: "local",
          mcpServers: expect.objectContaining({
            "sudocode-workflow": expect.any(Object),
          }),
        }),
        expect.stringContaining("Workflow Orchestration"),
        "claude-code"
      );
    });

    it("should update workflow status to running", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });

      await engine.startWorkflow(workflow.id);

      const updated = await engine.getWorkflow(workflow.id);
      expect(updated!.status).toBe("running");
      expect(updated!.startedAt).toBeDefined();
    });

    it("should store orchestrator execution ID on workflow", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });

      await engine.startWorkflow(workflow.id);

      const updated = await engine.getWorkflow(workflow.id);
      expect(updated!.orchestratorExecutionId).toBe("exec-orch");
      expect(updated!.orchestratorSessionId).toBe("session-orch");
    });

    it("should emit workflow_started event", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });

      const listener = vi.fn();
      eventEmitter.on(listener);

      await engine.startWorkflow(workflow.id);

      expect(listener).toHaveBeenCalledWith(
        expect.objectContaining({
          type: "workflow_started",
          workflowId: workflow.id,
        })
      );
    });

    it("should reject if workflow is not pending", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });

      await engine.startWorkflow(workflow.id);

      await expect(engine.startWorkflow(workflow.id)).rejects.toThrow(
        "Cannot start"
      );
    });
  });

  describe("pauseWorkflow", () => {
    it("should update status to paused", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);

      await engine.pauseWorkflow(workflow.id);

      const updated = await engine.getWorkflow(workflow.id);
      expect(updated!.status).toBe("paused");
    });

    it("should record pause event", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);

      await engine.pauseWorkflow(workflow.id);

      const events = wakeupService.getUnprocessedEvents(workflow.id);
      expect(events.some((e) => e.type === "workflow_paused")).toBe(true);
    });

    it("should emit workflow_paused event", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);

      const listener = vi.fn();
      eventEmitter.on(listener);

      await engine.pauseWorkflow(workflow.id);

      expect(listener).toHaveBeenCalledWith(
        expect.objectContaining({
          type: "workflow_paused",
          workflowId: workflow.id,
        })
      );
    });

    it("should reject if workflow is not running", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });

      await expect(engine.pauseWorkflow(workflow.id)).rejects.toThrow(
        "Cannot pause"
      );
    });
  });

  describe("resumeWorkflow", () => {
    it("should update status to running", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);
      await engine.pauseWorkflow(workflow.id);

      await engine.resumeWorkflow(workflow.id);

      const updated = await engine.getWorkflow(workflow.id);
      expect(updated!.status).toBe("running");
    });

    it("should record resume event", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);
      await engine.pauseWorkflow(workflow.id);

      // Clear existing events
      const pauseEvents = wakeupService.getUnprocessedEvents(workflow.id);
      wakeupService.markEventsProcessed(pauseEvents.map((e) => e.id));

      await engine.resumeWorkflow(workflow.id);

      // Check database directly since triggerWakeup marks events as processed
      const allEvents = db
        .prepare("SELECT * FROM workflow_events WHERE workflow_id = ?")
        .all(workflow.id) as Array<{ type: string }>;
      expect(allEvents.some((e) => e.type === "workflow_resumed")).toBe(true);
    });

    it("should trigger immediate wakeup", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);
      await engine.pauseWorkflow(workflow.id);

      // Clear existing events
      const pauseEvents = wakeupService.getUnprocessedEvents(workflow.id);
      wakeupService.markEventsProcessed(pauseEvents.map((e) => e.id));

      await engine.resumeWorkflow(workflow.id);

      // The createFollowUp should be called by triggerWakeup
      expect(executionService.createFollowUp).toHaveBeenCalled();
    });

    it("should reject if workflow is not paused", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);

      await expect(engine.resumeWorkflow(workflow.id)).rejects.toThrow(
        "Cannot resume"
      );
    });
  });

  describe("cancelWorkflow", () => {
    it("should update status to cancelled", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);

      await engine.cancelWorkflow(workflow.id);

      const updated = await engine.getWorkflow(workflow.id);
      expect(updated!.status).toBe("cancelled");
      expect(updated!.completedAt).toBeDefined();
    });

    it("should cancel orchestrator execution", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);

      await engine.cancelWorkflow(workflow.id);

      expect(executionService.cancelExecution).toHaveBeenCalledWith(
        "exec-orch"
      );
    });

    it("should emit workflow_cancelled event", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);

      const listener = vi.fn();
      eventEmitter.on(listener);

      await engine.cancelWorkflow(workflow.id);

      expect(listener).toHaveBeenCalledWith(
        expect.objectContaining({
          type: "workflow_cancelled",
          workflowId: workflow.id,
        })
      );
    });

    it("should reject if workflow is already cancelled", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });
      await engine.startWorkflow(workflow.id);
      await engine.cancelWorkflow(workflow.id);

      await expect(engine.cancelWorkflow(workflow.id)).rejects.toThrow(
        "Cannot cancel"
      );
    });
  });

  describe("retryStep", () => {
    it("should record retry event", async () => {
      // Create workflow with step
      createTestIssue(db, "i-test", "Test Issue");
      const workflow = await engine.createWorkflow({
        type: "issues",
        issueIds: ["i-test"],
      });
      await engine.startWorkflow(workflow.id);

      const stepId = workflow.steps[0].id;
      await engine.retryStep(workflow.id, stepId);

      const events = wakeupService.getUnprocessedEvents(workflow.id);
      const retryEvent = events.find(
        (e) => e.stepId === stepId && e.payload.action === "retry"
      );
      expect(retryEvent).toBeDefined();
    });

    it("should reject if step not found", async () => {
      const workflow = await engine.createWorkflow({
        type: "goal",
        goal: "Test",
      });

      await expect(
        engine.retryStep(workflow.id, "nonexistent")
      ).rejects.toThrow("not found");
    });
  });

  describe("skipStep", () => {
    it("should record skip event with reason", async () => {
      createTestIssue(db, "i-test", "Test Issue");
      const workflow = await engine.createWorkflow({
        type: "issues",
        issueIds: ["i-test"],
      });
      await engine.startWorkflow(workflow.id);

      const stepId = workflow.steps[0].id;
      await engine.skipStep(workflow.id, stepId, "Not needed");

      const events = wakeupService.getUnprocessedEvents(workflow.id);
      const skipEvent = events.find((e) => e.type === "step_skipped");
      expect(skipEvent).toBeDefined();
      expect(skipEvent!.payload.reason).toBe("Not needed");
    });
  });

  describe("getWorkflow", () => {
    it("should return null for non-existent workflow", async () => {
      const result = await engine.getWorkflow("nonexistent");
      expect(result).toBeNull();
    });

    it("should return workflow with parsed JSON fields", async () => {
      const workflow = await engine.createWorkflow(
        { type: "goal", goal: "Test" },
        { autonomyLevel: "full_auto" }
      );

      const result = await engine.getWorkflow(workflow.id);

      expect(result!.source).toEqual({ type: "goal", goal: "Test" });
      expect(result!.config.autonomyLevel).toBe("full_auto");
    });
  });

  describe("getReadySteps", () => {
    it("should return steps with no dependencies", async () => {
      createTestIssue(db, "i-1", "Issue 1");
      createTestIssue(db, "i-2", "Issue 2");

      const workflow = await engine.createWorkflow({
        type: "issues",
        issueIds: ["i-1", "i-2"],
      });

      const readySteps = await engine.getReadySteps(workflow.id);

      // Both should be ready (no dependencies)
      expect(readySteps.length).toBeGreaterThanOrEqual(1);
    });
  });
});
